---
layout: main_page
---

<section class="doc_title">
  <div class="container">
    <div class="row">
      <h2>Using the compare_strings() function</h2>
    </div>
  </div>
</section>

<section class="doc_body">
  <div class="container">
    <div class="row">
      <h5>
<br><br>
To compare strings, they must be formatted in a specific way. If they are not formatted correctly, the parser will return skewed results. To successfully format your string array, please abide by the following format.
<br><br>
As is stated in the name of this library, it is designed for dumb and lazy people to be able to use without getting stuck. That being said, it does not mean that this library is not versatile or useful. When you compare a set of strings ( see below for examples ), you must use the following format to get proper results from the parser:
<br><br>
<pre><code>
text=[ "String 1", "String 2", "String 3", "keyword=Your keyword" ]
</code></pre>
<br>
If you do not have a keyword, simply ignore the your keyword entry.
<br><br>
<pre><code>
text=[ "String 1", "String 2", "String 3" ]
</code></pre>
<br>
You can compare as many strings as you would like.
<br><br>
The output of the program is an array of strings and integers, contained like the following:
<br><br>
<pre><code>
[ [ 0, 0, "" ], [ 0, 0, "" ] ]
</code></pre>
<br>
Each element of the above array contains a reliability score, an applicability score, and a pattern. They are placed in the order reliability score, applicability score, pattern. The reliability score judges how often the pattern occurs. For example, if a pattern was found in two strings ouf of a thousand, then it would have a reliability score of 0 ( The minimum is 0, and the maximum is 100. The score is rounded to the nearest integer ). The applicability score judges how likely the pattern is to be correctly identified. An example of a pattern, with a reliability score of 50 and an applicability score of 80, is shown below.
<br><br>
<pre><code>
[ [ 50, 80, "pattern" ] ]
</code></pre>
<br>
A simple example of how to use this library is to compare two strings, each containing a name. The objective is to find the name, which is in both strings.
<br><br>
<pre><code>
from regex4dummies import regex4dummies

string_1 = """ My name is John Hill and I like to program artificial intelligence. """
string_2 = """ John Hill watches his computer learn. """

if __name__ == '__main__':
  combined_list = {}
  combined_list.append( string_1 )
  combined_list.append( string_2 )

  name_comparer = regex4dummies()
</code></pre>
<br>
There are three arguments that are required to be passed to the compare_strings() function, in this format:
<br><br>
<pre><code>
compare_strings( parser=parser, pattern_detection="semantic", text=string_list )
</code></pre>
<br>
Arguements:
<br>
<ul>
- "parser" : This is which parser you would like to use. There are currently three options:<br>
<li>'nltk' : This is a parser using nltk's POS tagger and a custom-made recursive grammar parser ( which is still under development, but should be usable and give good results )</li>
<li>'pattern' : This is a parser using pattern's built-in POS tagger and parser. None of this is custom made and this is very well developed. However, it still have a high rate of "failure", or incorrect results</li>
<li>'nlpnet' : This is a parser that has about a 90% correct rate. It is all built-in and is a little slow, but is very effective for short strings</li>
<li>'default' : If using the literal parser, the 'default' parser must be used</li>
</ul>
<ul>
- "pattern_detection" : Determines the kind of patterns detected<br>
<li>If this is set to "literal", a literal parse will be applied to the set of strings.</li>
<li>If "semantic", a semantic parse will be applied using the specified parser</li>
</ul>
<ul>
- "text" : This is covered in detail in the above section, so please look there for in-depth information about this argument
<br><br>
When the program is run, only one pattern will be printed. Below is the output. As seen, there is a 100% reliability score, and a 100% applicability score, followed by the pattern which is John Hill
<br><br>
<pre><code>
[[100, 100, "John Hill"]]
</code></pre>
      </h5>
    </div>
  </div>
</section>

<section class="doc_return">
  <div class="container">
    <div class="row">
      <a href="{{ site.url }}/documentation.html" class="pure-menu-button 3x-text"><h5><i class="fa fa-arrow-left fa-2x"></i>   Back to documentation</h5></a>
    </div>
  </div>
</section>
